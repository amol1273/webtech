def initialize_routing_table(graph, start_node):
    # Initialize distances to all nodes as infinity, except the start node
    distances = {node: float('inf') for node in graph}
    distances[start_node] = 0
    return distances

def distance_vector_routing(graph, start_node):
    distances = initialize_routing_table(graph, start_node)
    updated = True
    while updated:
        updated = False
        # Iterate over each node and its neighbors
        for node in graph:
            for neighbor, cost in graph[node]:
                # Update the distance if a shorter path is found
                if distances[node] + cost < distances[neighbor]:
                    distances[neighbor] = distances[node] + cost
                    updated = True
    return distances

# Example graph: each node has a list of (neighbor, cost) tuples
graph = {
    'A': [('B', 1), ('C', 4)],
    'B': [('A', 1), ('C', 2), ('D', 5)],
    'C': [('A', 4), ('B', 2), ('D', 1)],
    'D': [('B', 5), ('C', 1)]
}

# Run the distance-vector routing algorithm
start_node = input("Enter the start node (e.g., A, B, C, D): ")

# Check if the input node is valid
if start_node not in graph:
    print(f"Error: '{start_node}' is not a valid node.")
else:
    distances = distance_vector_routing(graph, start_node)

    print(f"Shortest distances from {start_node}:")
    for node, distance in distances.items():
        print(f"Distance to {node}: {distance}")
